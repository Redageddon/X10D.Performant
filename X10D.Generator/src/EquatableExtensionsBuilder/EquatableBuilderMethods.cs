using System;
using System.Collections.Generic;
using System.Text;

namespace X10D.Generator;

public partial class EquatableBuilder
{
    private static string GetArgs(int argsCount)
    {
        List<string> strings = new();
        StringBuilder argsStringBuilder = new();

        for (int i = 0; i < argsCount; i++)
        {
            strings.Add("T arg" + (i + 1));
        }

        argsStringBuilder.Append(string.Join(", ", strings));

        return argsStringBuilder.ToString();
    }

    private static string GetClass(string type, string binarySeparationType, bool isReversedType, int argsCount)
    {
        StringBuilder classBuilder = new();
        classBuilder.Append(Program.AutoGeneratedString);
        classBuilder.Append(StartingChunk);
        classBuilder.Append(GetParamsMethod(type));

        List<string> strings = new();

        for (int i = 2; i < argsCount + 1; i++)
        {
            strings.Add(GetOverloadsMethod(type, binarySeparationType, isReversedType, i));
        }

        classBuilder.AppendJoin(Environment.NewLine, strings);

        classBuilder.Append(EndingChunk);

        return classBuilder.ToString();
    }

    private static string GetOverloadsMethod(string type, string binarySeparationType, bool isReversedType, int argsCount)
    {
        string args = GetArgs(argsCount);

        string returns = GetReturnRecursive(argsCount - 1, binarySeparationType, isReversedType);

        return @$"        /// <include file='EquatableExtensions.g.xml' path='members/member[@name=""{type}Equals{argsCount}""]'/>
        public static bool {type}Equals<T>(this T value, {args})
            where T : IEquatable<T> =>
            {returns};
";
    }

    private static string GetParamsMethod(string type) =>
        $"        /// <include file='EquatableExtensions.g.xml' path='members/member[@name=\"{type}Equals1\"]'/>"
      + @$"
        public static bool {type}Equals<T>(this T value, params T[] comparisons)
            where T : IEquatable<T> =>
            AdvancedComparison<T, {type}>(value, comparisons);

";

    private static string GetReturnRecursive(int argsCount, string type, bool isTypeNot)
    {
        if (argsCount <= 0)
        {
            return $"value.Equals(arg{argsCount + 1})";
        }

        string currentValue = $"{GetReturnRecursive(argsCount - 1, type, isTypeNot)} {type} value.Equals(arg{argsCount + 1})";

        return isTypeNot
            ? $"!({currentValue})"
            : currentValue;
    }
}